---
title: "getting_started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{getting-started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# gimap tutorial

gimap performs analysis of dual-targeting CRISPR screening data, with the goal of aiding the identification of genetic interactions (e.g. cooperativity, synthetic lethality) in models of disease and other biological contexts. gimap analyzes functional genomic data generated by the pgPEN (paired guide RNAs for genetic interaction mapping) approach, quantifying growth effects of single and paired gene knockouts upon application of a CRISPR library. A multitude of CRISPR screen types can be used for this analysis, with helpful descriptions found in this review (https://www.nature.com/articles/s43586-021-00093-4). Use of pgPEN and GI-mapping in a paired gRNA format can be found here (https://pubmed.ncbi.nlm.nih.gov/34469736/).

```{r}
library(gimap)
```

```{r}
library(dplyr)
```

## Data requirements

Let's examine this example pgPEN counts table. It's divided into columns containing:

- `id`: an ID corresponding to the names of paired guides
- `seq_1`: gRNA sequence 1, targeting "paralog A"
- `seq_2`: gRNA sequence 2, targeting "paralog B"
- `Day00_RepA`: Gene Counts from Day 00 for Replicate A
- `Day05_RepA`: Gene Counts from Day 05 for Replicate A
- `Day22_RepA`: Gene Counts from Day 22 for Replicate A
- `Day22_RepB`: Gene Counts from Day 22 for Replicate B

```{r}
example_data <- get_example_data("count")
```

The metadata you have may vary slightly from this but you'll want to make sure you have the essential variables and information regarding how you collected your data.

```{r}
colnames(example_data)
```

This count data has ...

We also want the construct metadata

```{r}
example_pg_metadata <- get_example_data("meta")
```

```{r}
colnames(example_pg_metadata)
```

And the meta data has ...

## Setting up data

We're going to set up three datasets. Two are required; the first is the counts that the genetic interaction analysis will be used for.

The first data set contains the readcounts from each sample type. Required for analysis is a Day 0 (or plasmid) sample, and at least one further timepoint sample. The T0 sample, or plasmid sample, will represent the entire library before any type of selection has occurred during the length of the screen. This is the baseline for guide RNA representation. The length of time cells should remain in culture throughout the screen is heavily dependent on the type of selection occurring, helpful advice can be found in (https://www.nature.com/articles/s43586-021-00093-4). QC analysis will follow to correlate replicates if inputted. Comparison of early and late timepoints is possible in this function, but not required if early timepoints were not taken.

```{r}
example_counts <- example_data %>%
  select(c("Day00_RepA", "Day05_RepA", "Day22_RepA", "Day22_RepB", "Day22_RepC")) %>%
  as.matrix()
```

The next datasets are metadata that describe the dimensions of the count data.
- These both need to be data frames.
- The sizes of these metadata must correspond to the dimensions of the counts data.
- The first column of the pg_metadata must be a unique id

One of these (`example_pg_metadata`) is required because it is necessary to know the IDs and be able to map them to pgRNA constructs.

```{r}
example_pg_metadata <- example_data %>%
  select(c("id", "seq_1", "seq_2"))
```

# sample metadata is the information that describes the samples and is sorted the same way as the columns in the count data
example_sample_metadata <- data.frame(
  id = 1:5,
  day = as.factor(c("Day00", "Day05", "Day22", "Day22", "Day22")),
  rep = as.factor(c("RepA", "RepA", "RepA", "RepB", "RepC"))
)
```

We'll need to provide `example_counts`, `example_pg_id` and `example_pg_metadata` to `setup_data()`. We can provide `sample_metadata`, but it is not required at the moment. (but it likely will be???)

The current assumptions/requirements of datasets using this package are that

* the first count/numerical data column corresponds to day 0 of the screen, or where the plasmid data is
* there is a unique ID/row for each pgRNA construct

Now let's setup our data using `setup_data()`. Optionally we can provide the metadata in this function as well so that it is stored with the data.

```{r}
gimap_dataset <- setup_data(counts = example_counts,
                            pg_ids = example_pg_id,
                            pg_metadata = example_pg_metadata,
                            sample_metadata = example_sample_metadata)
```

You'll notice that this set up gives us a list of formatted data. This contains the original counts we gave `setup_data()` function but also normalized counts, and the total counts per sample.

- `raw_counts`: The original counts data that illustrates the number of cells alive in the sample. This data has samples as the columns and the paired guide constructs as rows.
- `counts_per_sample`: Add up all the counts for each sample over all of the paired guide designs.
- Transformed data: This section contains the various types of normalized and adjusted data made from the raw counts data.
- `count_norm` - For each sample, the data is normalized `-log10(( counts +1) /  total counts for the sample over all the pg designs ))`
- `cpm` - For each sample this is calculated by taking the `counts / total counts for the sample over all the pg designs)*1e6`
- `log2cpm`: log-2 transformed counts per million this is calculated by `log2(cpms + 1)`
- pg_metadata: paired guide metadata - information that describes the paired-guided RNA designs. This may include the sequences used in the CRISPR design as well as what genes are targeted.
- `sample_metadata`: Metadata that describes the samples. This likely includes the time point information, replicates, sample IDs, and any other additional information that is needed regarding the experimental setup.



```{r}
str(gimap_dataset)
```

explain how to run qc and what the parameter `params` is doing here.

Later explain other parameters and how they can be used

```{r}
run_qc(gimap_dataset,
       output_file = "example_qc_report.Rmd",
       overwrite = TRUE,
       quiet = TRUE)
```


The addition to this is that now a QC filter has been added to the `gimap_dataset` object, specifically found in `gimap_dataset$transformed_data$qc_filter`. It's a list of TRUE and FALSE. With TRUE meaning that it passes the filters and should be kept, and FALSE meaning that it didn't pass (right now the combined filter) and should not be kept for the analysis. Future work should let you select if you're using one, both, or neither of the filters.

```{r}
#head(gimap_dataset$qc$qc_filter)
```

The qc function also produces an HTML report for all of the plots and tables made while running the QC process.

```{r}
sessionInfo()
```
